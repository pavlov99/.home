#!/usr/bin/python

### MODULE: common.namedtuple

try:
    from collections import namedtuple
except ImportError:
    from operator import itemgetter as _itemgetter
    from keyword import iskeyword as _iskeyword
    import sys as _sys

    def namedtuple(typename, field_names, verbose=False, rename=False):
        """Returns a new subclass of tuple with named fields.

        >>> Point = namedtuple('Point', 'x y')
        >>> Point.__doc__                   # docstring for the new class
        'Point(x, y)'
        >>> p = Point(11, y=22)             # instantiate with positional args or keywords
        >>> p[0] + p[1]                     # indexable like a plain tuple
        33
        >>> x, y = p                        # unpack like a regular tuple
        >>> x, y
        (11, 22)
        >>> p.x + p.y                       # fields also accessable by name
        33
        >>> d = p._asdict()                 # convert to a dictionary
        >>> d['x']
        11
        >>> Point(**d)                      # convert from a dictionary
        Point(x=11, y=22)
        >>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields
        Point(x=100, y=22)

        """

        # Parse and validate the field names.  Validation serves two purposes,
        # generating informative error messages and preventing template injection attacks.
        if isinstance(field_names, basestring):
            field_names = field_names.replace(',', ' ').split() # names separated by whitespace and/or commas
        field_names = tuple(map(str, field_names))
        if rename:
            names = list(field_names)
            seen = set()
            for i, name in enumerate(names):
                if (not min(c.isalnum() or c=='_' for c in name) or _iskeyword(name)
                    or not name or name[0].isdigit() or name.startswith('_')
                    or name in seen):
                        names[i] = '_%d' % i
                seen.add(name)
            field_names = tuple(names)
        for name in (typename,) + field_names:
            if not min(c.isalnum() or c=='_' for c in name):
                raise ValueError('Type names and field names can only contain alphanumeric characters and underscores: %r' % name)
            if _iskeyword(name):
                raise ValueError('Type names and field names cannot be a keyword: %r' % name)
            if name[0].isdigit():
                raise ValueError('Type names and field names cannot start with a number: %r' % name)
        seen_names = set()
        for name in field_names:
            if name.startswith('_') and not rename:
                raise ValueError('Field names cannot start with an underscore: %r' % name)
            if name in seen_names:
                raise ValueError('Encountered duplicate field name: %r' % name)
            seen_names.add(name)

        # Create and fill-in the class template
        numfields = len(field_names)
        argtxt = repr(field_names).replace("'", "")[1:-1]   # tuple repr without parens or quotes
        reprtxt = ', '.join('%s=%%r' % name for name in field_names)
        template = '''class %(typename)s(tuple):
        '%(typename)s(%(argtxt)s)' \n
        __slots__ = () \n
        _fields = %(field_names)r \n
        def __new__(_cls, %(argtxt)s):
            return _tuple.__new__(_cls, (%(argtxt)s)) \n
        @classmethod
        def _make(cls, iterable, new=tuple.__new__, len=len):
            'Make a new %(typename)s object from a sequence or iterable'
            result = new(cls, iterable)
            if len(result) != %(numfields)d:
                raise TypeError('Expected %(numfields)d arguments, got %%d' %% len(result))
            return result \n
        def __repr__(self):
            return '%(typename)s(%(reprtxt)s)' %% self \n
        def _asdict(self):
            'Return a new dict which maps field names to their values'
            return dict(zip(self._fields, self)) \n
        def _replace(_self, **kwds):
            'Return a new %(typename)s object replacing specified fields with new values'
            result = _self._make(map(kwds.pop, %(field_names)r, _self))
            if kwds:
                raise ValueError('Got unexpected field names: %%r' %% kwds.keys())
            return result \n
        def __getnewargs__(self):
            return tuple(self) \n\n''' % locals()
        for i, name in enumerate(field_names):
            template += '        %s = _property(_itemgetter(%d))\n' % (name, i)
        if verbose:
            print template

        # Execute the template string in a temporary namespace
        namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename,
                         _property=property, _tuple=tuple)
        try:
            exec template in namespace
        except SyntaxError, e:
            raise SyntaxError(e.message + ':\n' + template)
        result = namespace[typename]

        # For pickling to work, the __module__ variable needs to be set to the frame
        # where the named tuple is created.  Bypass this step in enviroments where
        # sys._getframe is not defined (Jython for example) or sys._getframe is not
        # defined for arguments greater than 0 (IronPython).
        try:
            result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')
        except (AttributeError, ValueError):
            pass

        return result

_TestPoint = namedtuple('_TestPoint', 'x, y')
def test_pickle():
    """
    Verify that instances can be pickled

    >>> from cPickle import loads, dumps
    >>> p = _TestPoint(x=10, y=20)
    >>> p == loads(dumps(p, -1))
    True
    """
    pass

def test_override():
    """
    Test and demonstrate ability to override methods

    >>> class Point(namedtuple('Point', 'x y')):
    ...     @property
    ...     def hypot(self):
    ...         return (self.x ** 2 + self.y ** 2) ** 0.5
    ...     def __str__(self):
    ...         return 'Point: x=%6.3f y=%6.3f hypot=%6.3f' % (self.x, self.y, self.hypot)
    ...
    >>> for p in Point(3,4), Point(14,5), Point(9./7,6):
    ...     print p
    Point: x= 3.000 y= 4.000 hypot= 5.000
    Point: x=14.000 y= 5.000 hypot=14.866
    Point: x= 1.286 y= 6.000 hypot= 6.136
    """
    pass

def test_replace():
    """
    >>> class Point(namedtuple('Point', 'x y')):
    ...     'Point class with optimized _make() and _replace() without error-checking'
    ...     _make = classmethod(tuple.__new__)
    ...     def _replace(self, _map=map, **kwds):
    ...         return self._make(_map(kwds.get, ('x', 'y'), self))
    >>> print Point(11, 22)._replace(x=100)
    Point(x=100, y=22)
    """
    pass

def _test():
    import doctest
    doctest.testmod()

# if __name__ == "__main__":
#     _test()
# 

### MODULE: tabkit.datasrc

import os
from itertools import izip
pass # from common.namedtuple import namedtuple

TYPES = set([
    'float',
    'int',
    'str',
    'bool',
    'any',
])

class DataField(namedtuple('DataField', 'name type')):
    def __repr__(self):
        return "%s(%r, %r)" % (
            self.__class__.__name__, self.name, self.type
        )

class SortType(object):
    STRING = 'str'
    NUMERIC = 'num'
    GENERAL_NUMERIC = 'general'
    HUMAN_NUMERIC = 'human'
    MONTH = 'month'

    @classmethod
    def is_valid(self, sort_type):
        return sort_type in (
            self.STRING,
            self.NUMERIC,
            self.GENERAL_NUMERIC,
            self.HUMAN_NUMERIC,
            self.MONTH,
        )

class DataFieldOrder(object):

    def __init__(self, name, sort_type=None, desc=None):
        self.name = name
        self.desc = desc
        self.sort_type = sort_type
        if self.desc == None:
            self.desc = False
        if self.sort_type == None:
            self.sort_type = SortType.STRING
        if not SortType.is_valid(self.sort_type):
            raise Exception('Unknown sort type %r' % (self.sort_type,))

    def __eq__(self, other):
        return (
            self.name == other.name
            and self.sort_type == other.sort_type
            and self.desc == other.desc
        )

    def __ne__(self, other):
        return not (self == other)

    def __repr__(self):
        return "%s(%r, sort_type=%r, desc=%r)" % (
            self.__class__.__name__, self.name, self.sort_type, self.desc
        )

def copy_field_order(field_order, name=None):
    return DataFieldOrder(
        name = name or field_order.name,
        sort_type = field_order.sort_type,
        desc = field_order.desc,
    )

def unix_sort_flags(field_order):
    sort_flags = ''

    if field_order.sort_type == SortType.NUMERIC:
        sort_flags += 'n'
    elif field_order.sort_type == SortType.GENERAL_NUMERIC:
        sort_flags += 'g'
    elif field_order.sort_type == SortType.HUMAN_NUMERIC:
        sort_flags += 'h'
    elif field_order.sort_type == SortType.MONTH:
        sort_flags += 'M'

    if field_order.desc:
        sort_flags += 'r'

    return sort_flags

def header_order_field(order_field):
    order_str = order_field.name
    if order_field.desc:
        order_str += ':desc'
    if order_field.sort_type == SortType.NUMERIC:
        order_str += ':num'
    if order_field.sort_type == SortType.GENERAL_NUMERIC:
        order_str += ':general'
    if order_field.sort_type == SortType.HUMAN_NUMERIC:
        order_str += ':human'
    if order_field.sort_type == SortType.MONTH:
        order_str += ':month'
    return order_str

def field_order_from_header(name, modifiers):
    desc = None
    sort_type = None
    for modifier in modifiers:
        if SortType.is_valid(modifier):
            if sort_type != None:
                raise Exception('Conflicting sort types %r and %r' % (sort_type, modifier))
            sort_type = modifier
        elif modifier in ('asc', 'desc'):
            if desc != None:
                raise Exception('Ambiguous order direction in %r' % (order_field_str,))
            if modifier == 'asc':
                desc = False
            else:
                desc = True
        else:
            raise Exception('Unknown order modifier %r' % (modifier,))
    return DataFieldOrder(name, sort_type, desc)

class DataOrder(object):
    def __init__(self, data_order):
        self.data_order = data_order

    def fields_are_ordered(self, field_names):
        for field_name, order in zip(field_names, self.data_order):
            if field_name != order.name:
                return False
        return True

    def is_ordered_by(self, data_order):
        if isinstance(data_order, DataOrder):
            data_order = data_order.data_order
        data_order = list(data_order)
        if len(self.data_order) < len(data_order):
            return False
        for required, actual in zip(data_order, self.data_order):
            if required != actual:
                return False
        return True

    def __nonzero__(self):
        return bool(self.data_order)

    def __iter__(self):
        return iter(self.data_order)

    def __repr__(self):
        return "%s(%r)" % (
            self.__class__.__name__, self.data_order
        )

class DataDesc(object):
    def __init__(self, fields, order=None, size=None):
        self.size = size
        self.fields = fields
        if isinstance(order, DataOrder):
            self.order = order
        else:
            self.order = DataOrder(order or [])
        self.field_names = dict((field.name, idx) for idx, field in enumerate(self.fields))
        if len(self.fields) != len(self.field_names):
            raise Exception("Conflicting field names in %r" % (self.fields,))
        for order_field in self.order:
            if order_field.name not in self.field_names:
                raise Exception('Unknown ordering field name %r' % (order_field.name,))

    def __getitem__(self, idx):
        assert isinstance(idx, slice)
        fields = self.fields[idx]
        field_names = list(field.name for field in fields)
        order = list(self.order)
        for order_field in order:
            if order_field.name not in field_names:
                break
            order.append(order_field)
        return DataDesc(fields, order, self.size)

    def __add__(self, desc):
        return paste_data_desc(self, desc)

    def __radd__(self, desc):
        return paste_data_desc(desc, self)

    def field_index(self, name):
        return self.field_names[name]

    def get_field(self, name):
        return self.fields[self.field_names[name]]

    def has_field(self, name):
        return name in self.field_names

    def __repr__(self):
        if self.order and self.size == None:
            return "%s(%r, %r)" % (
                self.__class__.__name__, self.fields, self.order
            )
        if not self.order and self.size == None:
            return "%s(%r)" % (
                self.__class__.__name__, self.fields
            )
        return "%s(%r, %r, %r)" % (
            self.__class__.__name__, self.fields, self.order, self.size
        )

def make_data_field(field):
    if isinstance(field, DataField):
        return field
    if isinstance(field, tuple) and isinstance(field[0], str) and field[1] in TYPES:
        return DataField(*field)
    raise Exception("Can't convert %r to DataField" % (field,))

def make_data_desc(desc):
    if isinstance(desc, tuple) and isinstance(desc[0], str) and desc[1] in TYPES:
        return DataDesc([DataField(*desc)])
    if isinstance(desc, list):
        return DataDesc(list(make_data_field(item) for item in desc))
    if isinstance(desc, DataDesc):
        return desc
    try:
        return DataDesc([make_data_field(desc)])
    except Exception, err:
        pass
    raise Exception("Can't convert %r to DataDesc" % (desc,))

def paste_data_desc(d1, d2):
    """
    >>> from tabkit.header import parse_header

    >>> parse_header('# a c:int')[:1] + ('b', 'str')
    DataDesc([DataField('a', 'any'), DataField('b', 'str')])

    >>> parse_header('# a b:int') + ('b', 'str')
    Traceback (most recent call last):
        ...
    Exception: Conflicting fields ['b'] in DataDesc([DataField('a', 'any'), DataField('b', 'int')]) and DataDesc([DataField('b', 'str')])

    >>> parse_header('# a #ORDER: a #SIZE: 2') + [('b', 'str')]
    DataDesc([DataField('a', 'any'), DataField('b', 'str')], DataOrder([DataFieldOrder('a', sort_type='str', desc=False)]))

    >>> ('b','str') + parse_header('# a #ORDER: a #SIZE: 2')
    DataDesc([DataField('b', 'str'), DataField('a', 'any')], DataOrder([DataFieldOrder('a', sort_type='str', desc=False)]))
    """
    d1 = make_data_desc(d1)
    d2 = make_data_desc(d2)
    isect = list(set(field.name for field in d1.fields).intersection(
        field.name for field in d2.fields
    ))
    if isect:
        raise Exception("Conflicting fields %r in %r and %r" % (isect, d1, d2))
    if d1.size == None or d2.size == None:
        size = None
    else:
        size = d1.size + d2.size
    return DataDesc(
        fields = d1.fields + d2.fields,
        order = d1.order or d2.order,
        size = size,
    )

def merge_data_desc(desc1, desc2):
    return DataDesc(
        fields = merge_data_fields(desc1.fields, desc2.fields),
        order = merge_data_order(desc1.order, desc2.order),
    )

def merge_data_fields(fields1, fields2):
    if len(fields1) != len(fields2):
        raise Exception('Incompatible data fields: %r and %r' % (
            fields1, fields2,
        ))

    fields = []
    for field1, field2 in zip(fields1, fields2):
        if field1.name != field2.name:
            raise Exception('Incompatible data fields: %r and %r' % (
                fields1, fields2,
            ))
        if field1.type == field2.type:
            fields.append(DataField(field1.name, field1.type))
        elif field1.type == 'any':
            fields.append(DataField(field1.name, field2.type))
        elif field2.type == 'any':
            fields.append(DataField(field1.name, field1.type))
        else:
            raise Exception('Incompatible data fields: %r and %r' % (
                fields1, fields2,
            ))

    return fields

def merge_data_order(order1, order2):
    order = []
    for ord1, ord2 in zip(order1, order2):
        if ord1 == ord2:
            order.append(copy_field_order(ord1))
        else:
            break
    return DataOrder(order)

def rename_fields(desc, renamings):
    new_fields = []
    for field in desc.fields:
        if field.name in renamings:
            new_fields.append(DataField(renamings[field.name], field.type))
        else:
            new_fields.append(DataField(field.name, field.type))

    new_order = []
    for field in desc.order:
        if field.name in renamings:
            new_order.append(copy_field_order(
                field, name=renamings[field.name],
            ))
        else:
            new_order.append(copy_field_order(
                field, name=field.name,
            ))

    return DataDesc(new_fields, new_order)

def convertible(from_type, to_type):
    if from_type == 'any' or to_type == 'any':
        return True
    if to_type == from_type:
        return True
    if to_type == 'str':
        return True
    if to_type == 'float' and from_type in ('int', 'bool'):
        return True
    if to_type == 'int' and from_type == 'bool':
        return True
    return False

def _test():
    import doctest
    doctest.testmod()

# if __name__ == "__main__":
#     _test()

### MODULE: tabkit.header

import os
import re

pass # from tabkit.datasrc import DataField, DataFieldOrder, DataDesc, SortType
pass # from tabkit.datasrc import header_order_field, field_order_from_header

def field_split(fields_str):
    return re.split(r'[;,\s]+', fields_str.strip())

def parse_header_order(zone_fields):
    for order_field_str in zone_fields:
        order_field = order_field_str.strip().split(':')
        yield field_order_from_header(order_field[0], order_field[1:])

def parse_header(header):
    """
    >>> header = "# shows:int clicks:int ctr:float rel url #ORDER: url:asc, ctr:desc:num"
    >>> parse_header(header) #doctest: +NORMALIZE_WHITESPACE
    DataDesc([DataField('shows', 'int'),
            DataField('clicks', 'int'),
            DataField('ctr', 'float'),
            DataField('rel', 'any'),
            DataField('url', 'any')],
        DataOrder([DataFieldOrder('url', sort_type='str', desc=False),
            DataFieldOrder('ctr', sort_type='num', desc=True)]))
    """
    if not header.startswith('#'):
        raise Exception('Bad header')
    else:
        data_fields = []
        data_order = []
        data_size = None

        zones = header[1:].split('#')
        fields_str = zones[0]
        fields = field_split(fields_str)
        for field in fields:
            field_parts = field.split(':')
            field_name = field_parts[0]
            field_type = 'any'
            if len(field_parts) == 2:
                field_type = field_parts[1]
            elif len(field_parts) > 2:
                raise Exception('Invalid field %r' % (field,))
            data_fields.append(DataField(field_name, field_type))

        for zone in zones[1:]:
            zone_name, zone_data = zone.strip().split(None, 1)
            if zone_name == 'ORDER:':
                data_order = list(parse_header_order(field_split(zone_data)))
            elif zone_name == 'SIZE:':
                data_size = int(zone_data)
            else:
                raise Exception('Bad header, invalid zone %r' % (zone_name,))

        return DataDesc(data_fields, data_order, data_size)

def make_header(data_desc):
    r"""
    >>> desc = DataDesc(
    ...     [DataField('shows', 'int'), DataField('url', 'any')],
    ...     [
    ...         DataFieldOrder('url', desc=True),
    ...         DataFieldOrder('shows', sort_type=SortType.NUMERIC),
    ...     ],
    ... )
    >>> make_header(desc)
    '# shows:int\turl #ORDER: url:desc\tshows:num\n'
    """
    fields = []
    for field in data_desc.fields:
        if field.type == 'any':
            fields.append(field.name)
        else:
            fields.append(field.name + ':' + field.type)
    order = []
    for order_field in data_desc.order:
        order.append(header_order_field(order_field))
    header = '# ' + '\t'.join(fields)
    if order:
        header += ' #ORDER: ' + '\t'.join(order)
    if data_desc.size != None:
        header += ' #SIZE: ' + str(data_desc.size)
    header += "\n"
    return header

def read_fd_header(fd):
    header = ''
    while header[-1:] != '\n':
        ch = os.read(fd, 1)
        if ch == '':
            break
        header += ch
    return header

def read_file_header(fname):
    fobj = open(fname)
    try:
        header = fobj.readline()
    finally:
        fobj.close()
    return header

def _test():
    import doctest
    doctest.testmod()

# if __name__ == "__main__":
#     _test()

### MAIN


import sys
import tempfile
pass # from tabkit.header import parse_header, make_header

class ColWidthCalc(object):
    def __init__(self):
        self.col_widths = {}

    def __call__(self, lines):
        col_widths = self.col_widths
        for i, line in enumerate(lines):
            if i == 0 and line.startswith('#'):
                line = make_header(parse_header(line))
            fields = line.rstrip().split('\t')
            for field_id, field in enumerate(fields):
                col_widths[field_id] = max(col_widths.get(field_id, 0), len(field))
            yield line

    def get_widths(self):
        return [min(width, 100) for field_id, width in sorted(self.col_widths.iteritems())]

def fmt_line(line, widths):
    fields = line.rstrip().split('\t')
    fields_widths = zip(fields, widths)
    fmt_line = ' | '.join("%%-%ds" % (wid,) for field, wid in fields_widths)
    return fmt_line % tuple(fields)

def main():
    col_width_calc = ColWidthCalc()
    tmpfile = tempfile.TemporaryFile()
    tmpfile.writelines(col_width_calc(sys.stdin))
    tmpfile.seek(0)

    for i, line in enumerate(tmpfile):
        if i == 0 and line.startswith('#'):
            line = '\t'.join(field.name for field in parse_header(line).fields)
            print fmt_line(line, col_width_calc.get_widths())
            print '-' * sum(w + 3 for w in col_width_calc.get_widths())
        else:
            print fmt_line(line, col_width_calc.get_widths())

if __name__ == '__main__':
    main()

